Emerald
=======


## Consideraciones Léxicas

A continuación se presentan las palabras reservadas del lenguaje. Éstas no pueden ser utilizadas como identificadores ni redefinidas.

    boolbasaur    charizard    intmonchan    floatzel    voidporeon   onix    
    registeer     unown        true          false       const        var
    for           from         to            by          while        return
    if            elsif        else          read        print        BOOM
    tag           continue     switch        case        default

Un identificador es una secuencia de caracteres alfanúmericos y el símbolo `_`, que empieza con una letra. Emerald es sensible a mayúsculas, 
por lo tanto los identificadores `Ejem`, `ejem` y `eJEm` son diferentes.

Los enteros, **`intmonchan`**, se representan con una secuencia de dígitos del `0` al `9`.

Los floats, **`floatzel`**, empiezan con una secuencia de dígitos, luego seguida por un punto y termina con otra secuencia de dígitos. 
Por ejemplo, `0.28`, `28.0` son números válidos pero `.28` y `28.` no.

Las cadenas de caracteres, **`onix`**, son una secuencia de caracteres ASCII entre comillas dobles. Por ejemplo:

     "Emerald FTW"    "pokemon"    "Hola!"

Un comentario simple (de una linea) son representados de la siguiente manera:

    # Hola, este comentario es de una linea.

Un comentario de varias lineas se representa así: 

    /* Este comentario es de varias
       lineas en el lenguaje Emerald.
       Es muy chevere. */

## Arreglos

Los arreglos son declarados de la siguiente manera:

    <tipo> <identificador> [ <número> .. <número> ]

Por ejemplo:

    intmonchan arreglo1[1..10]
    floatzel   arreglo2[0..99]
    charizard  arreglo3[9..19]

## Tipos Estructurados

Un registro, `registeer`, se declara de la siguiente manera:

    registeer <identificador> {
        <tipo1> <identificador1> ;
        <tipo2> <identificador2> := <inicialización> ;
        ...
        <tipoN> <identificadorN> ;
    }
    
Uniones, `unown`, se representan de la misma manera:

    unown <identificador> {
        <tipo1> <identificador1> ;
        <tipo2> <identificador2> := <inicialización> ;
        ...
        <tipoN> <identificadorN> ;
    }

Para acceder a un atributo de un registro o unión, se utiliza el operador `.`.

    registro.campo
    
    

## Vacío

* voidporeon - void

## Selector

    if <expresiónBooleana> {
        ...
    }

    if <expresiónBooleana> 
       <instrucción>;

    if <expresiónBooleana> {
        ...
    } else {
        ...
    }

    if <expresiónBooleana> {
        ...
    } elsif <expresiónBooleana2> {
        ...
    }

    if <expresiónBooleana> {
        ...
    } elsif <expresiónBooleana2> {
        ...
    } else {
        ...
    }

## Iteraciones

    for <identificador> from <expresión> to <expresión> {
         ...
    }

    for <identificador> from <expresión> to <expresión> by <expresión> {
         ...
    }

    while <expresiónBooleana> {
         ...
    }

## Entrada/Salida

* read()
* print() 

## Operadores

_En orden de precedencia de mayor a menor_

* !    - unario
* ^
* *    \    %
* +    - 
* <    <=   >=    > 
* =    !=
* &&
* ||

## Asignación

    :=

## Declaración e Inicialización de Variables

Pasado por Valor

    <tipo> <identificador> ;
    <tipo> <identificador> := <valor> ;
    <tipo> <identificador1> , <identificador2> ;
    <tipo> <identificador1> , <identificador2> := <valor1> , <valor2> ;


Pasado por Referencia

    <tipo> var <identificador> ;
    <tipo> <identificador, var <identificador> ;

## Etiquetas

Se representan de la siguiente manera:

    tag: <identificador> ;


* BOOM - break
* BOOM etiqueta - break 
* continue etiqueta
* continue

## Switch

Los rangos son disjuntos y valor default es opcional. Deben haber al menos
dos case en el switch.

    switch <expresión> {
        case <rango1> -> { ... }
        case <rango2> -> { ... }
        ...
        default       -> { ... }
    }

