Emerald
=======

Campos, M. & Salcedo, A.

--- 

## Consideraciones Léxicas

A continuación se presentan las palabras reservadas del lenguaje. Éstas no pueden ser utilizadas como 
identificadores ni redefinidas.

    boolbasaur    charizard    intmonchan    floatzel    voidporeon   onix    
    registeer     unown        true          false       const        var
    for           from         to            by          while        return
    if            elsif        else          read        print        println
    tag           BOOM         continue      switch      case         default

Un identificador es una secuencia de caracteres alfanúmericos o el símbolo _underscore_ `_`, que empieza con una letra.
Los identificadores son sensibles a mayúsculas, por lo tanto `ident`, `Ident` y `IDent` son diferentes.

Los enteros se representan con una secuencia de dígitos del `0` al `9`.

Los floatantes empiezan con una secuencia de dígitos, luego seguida por un punto y termina con otra secuencia de dígitos. 
Por ejemplo, `0.28`, `28.0` son números válidos pero `.28` y `28.` no.

Las cadenas de caracteres son una secuencia de caracteres ASCII entre comillas dobles. Por ejemplo:

     "Emerald FTW"    "pokemon"    "Hola!"

Los comentarios simples (de una linea) son representados de la siguiente manera:

    # Hola, este comentario es de una linea.

El lenguaje Emerald maneja comentarios de varias líneas. Por ejemplo: 

    /* Este comentario es de varias
       lineas en el lenguaje Emerald.
       Es muy chevere. */


## Estructura del programa

Un programa en Emerald consiste de una secuencia de definiciones de variables globales, 
funciones y tipos definidos por el usuario (`registeer`s y `unowns`s).

Todo programa debe al menos tener una función sin parametros denominada **`main`** que 
retorna `voidporeon` (vacío).  

## Reglas de Alcance

Emerald tiene alcance estático. El alcance más externo corresponde a las declaraciones
globales (variables, funciones y tipos definidos por el usuario). Después en cada bloque 
se abre un alcance nuevo. También se abre un alcance cuando se declara la variable 
de una instrucción `for`. 
    
Las funciones y los registros sólo se pueden declarar en el alcance global. No importa el
orden de su definición, éstas son visibles entre sí. No se pueden definir funciones, 
registros, uniones o variables globales con el mismo nombre.

La declaración de variables en un bloque sólo se puede hacer al principio del mismo. 
Por ejemplo:

    # Valido
    
    voidporeon funcionValida {
    
        intmonchan int;
        boolbasaur bool;
        
        <instrucciones>
        ...
    }
    
    # Invalido
    
    voidporeon funcionInvalida {
    
        intmonchan int;
        
        int := 1;
        
        boolbasaur bool;
        
        <instrucciones>
        ...

    }
    

Se pueden declarar variables con el mismo nombre tal que éstas no estén en el mismo 
alcance y que no tengan el mismo nombre que una función, registro o unión ya definido. 
Si una variable se declara en el alcance actual y ya existe una con el mismo nombre en 
un alcance externo entonces la primera opaca a la segunda.


## Tipos

Los tipos primitivos de Emerald son los siguientes:

* **intmonchan**: Tipo entero.
* **floatzel**:   Tipo punto flotante.
* **charizard**:  Tipo caracter ASCII.
* **boolbasaur**: Tipo booleano (true, false).
* **onix**:       Secuencia de caracteres ASCII inmutable.
* **voidporeon**: El vacío. Utilizado solamente en funciones. 

### Arreglos

* Los arreglos son unidimensionales con índices arbitrarios de cualquier tipo primitivo 
* de Emerald menos `voidporeon`. 
* Además son de tamaño fijo y constante a tiempo de compilación. Esto significa que una 
vez declarados, el tamaño de un arreglo no se puede cambiar. 
* Los índices de un arreglo deben ser de tipo entero.
* Cuando se intenta de acceder a una posición fuera de los límites de un arreglo, 
ocurre un error a tiempo de ejecución.


Los arreglos son declarados de la siguiente manera:

    <tipo> <identificador> [ <número> .. <número> ]

Ejemplo:

    intmonchan arreglo1[1..10]
    floatzel   arreglo2[0..42]
    charizard  arreglo3[9..19]

### Tipos Estructurados

En Emerald se pueden crear tipos compuestos, los cuales consisten de una colección 
de campos de tipos primitivos y tipos definidos por el usuario. 


Los registros, `registeer`, se definen de la siguiente manera:

    registeer <identificador> {
    
        <tipo1> <identificador1> ;
        <tipo2> <identificador2> := <inicialización> ;
        ...
        <tipoN> <identificadorN> ;
    }
    
Uniones, `unown`, se representan de la misma manera:

    unown <identificador> {
        
        <tipo1> <identificador1> ;
    
        <tipo2> <identificador2> := <inicialización> ;
        ...
        <tipoN> <identificadorN> ;
    }

Las declaraciones de variables de tipos compuestos se realizan de la siguiente manera:

    registeer <nombreRegistro> <identificador1>;
    unown     <nombreUnion>    <identificador2>;


Para acceder a un atributo de un registro o unión, se utiliza el operador `.`.

    <identificador>.<campo>

Un campo de un tipo compuesto no puede contener el mismo tipo que está siendo declarado.
Por ejemplo:
    
    registeer unRegistro {
    
        intmonchan int;
        registeer unRegistro reg;   # Esto es invalido.
        ...
    }
    
    unown unUnion {
    
        boolbasaur bool;
        unown unaUnion un;   # Esto es invalido.
        ...
    }

A continuación se encuentra un ejemplo de cómo definir y utilizar tipos compuestos:

    registeer unRegistro {   
        intmonchan campo1; 
        floatzel   campo2;
    }
    
    unown unaUnion {
        intmonchan var1;
        floatzel   var2;
        boolbasaur var3;
    }

    voidporeon main () {
    
       registeer unRegistro reg;
       unown     unaUnion   un;
       
       reg.campo1 := 42;
       unaUnion.var1 := 9;
    }
   
## Funciones


    
## Selector

    if <expresiónBooleana> {
        ...
    }

    if <expresiónBooleana> 
       <instrucción>;

    if <expresiónBooleana> {
        ...
    } else {
        ...
    }

    if <expresiónBooleana> {
        ...
    } elsif <expresiónBooleana2> {
        ...
    }

    if <expresiónBooleana> {
        ...
    } elsif <expresiónBooleana2> {
        ...
    } else {
        ...
    }

### Iteraciones



    for <identificador> from <expresión> to <expresión> {
         ...
    }

    for <identificador> from <expresión> to <expresión> by <expresión> {
         ...
    }

    while <expresiónBooleana> {
         ...
    }

### Entrada/Salida

Las palabras reservadas para entreda y salida son `read`, `print` y `println`.

    intmonchan num;
    print ("Ingrese su numero favorito: ");
    read(num);
    ...
    
### Precedencia de Operadores

De mayor a menor precedencia.

             Operador | Descripción
             -------- | -----------
    !    - unario     | Negación booleana y menos unario
    ^                 | Potenciación
    *    /    %       | Multiplicación, división y módulo
    +    -            | Suma y resta
    <    <=   >=    > | Relacionales
    =    !=           | Igualdad y desigualdad
    &&                | Operador lógico y
   &#124;&#124;       | Operador lógico o

### Asignación

    :=

### Declaración e Inicialización de Variables

Pasado por Valor

    <tipo> <identificador> ;
    <tipo> <identificador> := <valor> ;
    <tipo> <identificador1> , <identificador2> ;
    <tipo> <identificador1> , <identificador2> := <valor1> , <valor2> ;


Pasado por Referencia

    <tipo> var <identificador> ;
    <tipo> <identificador, var <identificador> ;

### Etiquetas

Se representan de la siguiente manera:

    tag: <identificador> ;


* BOOM - break
* BOOM etiqueta - break 
* continue etiqueta
* continue

### Switch

Los rangos son disjuntos y valor default es opcional. Deben haber al menos
dos case en el switch.

    switch <expresión> {
        case <rango1> -> { ... }
        case <rango2> -> { ... }
        ...
        default       -> { ... }
    }

### Conversiones Explícitas

* intToFloatzel
* floatToIntmonchan
* charToIntmonchan
* intToCharizard
