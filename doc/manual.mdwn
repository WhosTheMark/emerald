Emerald
=======


## Consideraciones Léxicas

A continuación se presentan las palabras reservadas del lenguaje. Éstas no pueden ser utilizadas como identificadores ni redefinidas.

    boolbasaur    charizard    intmonchan    floatzel    voidporeon   onix    
    registeer     unown        true          false       const        var
    for           from         to            by          while        return
    if            elsif        else          read        print        println
    tag           BOOM         continue      switch      case         default

Un identificador es una secuencia de caracteres alfanúmericos y el símbolo `_`, que empieza con una letra. Emerald es sensible a mayúsculas, 
por lo tanto los identificadores `Ejem`, `ejem` y `eJEm` son diferentes.

Los enteros se representan con una secuencia de dígitos del `0` al `9`.

Los floats empiezan con una secuencia de dígitos, luego seguida por un punto y termina con otra secuencia de dígitos. 
Por ejemplo, `0.28`, `28.0` son números válidos pero `.28` y `28.` no.

Las cadenas de caracteres son una secuencia de caracteres ASCII entre comillas dobles. Por ejemplo:

     "Emerald FTW"    "pokemon"    "Hola!"

Un comentario simple (de una linea) son representados de la siguiente manera:

    # Hola, este comentario es de una linea.

Un comentario de varias lineas se representa así: 

    /* Este comentario es de varias
       lineas en el lenguaje Emerald.
       Es muy chevere. */

      
## Tipos

Los tipos que se manejan en Emerald son los siguientes:

* **intmonchan**: Tipo entero.
* **floatzel**:   Tipo punto flotante.
* **charizard**:  Tipo caracter ASCII.
* **boolbasaur**: Tipo booleano (true, false).
* **onix**:       Secuencia de caracteres ASCII inmutable.
* **voidporeon**: El vacío. Utilizado solamente en funciones. 

### Arreglos

Los arreglos son unidimensionales con índices arbitrarios. 
Además son de tamaño fijo y constante a tiempo de compilación.

Los arreglos son declarados de la siguiente manera:

    <tipo> <identificador> [ <número> .. <número> ]

Por ejemplo:

    intmonchan arreglo1[1..10]
    floatzel   arreglo2[0..99]
    charizard  arreglo3[9..19]

### Tipos Estructurados

Un registro, `registeer`, se declara de la siguiente manera:

    registeer <identificador> {
    
        <tipo1> <identificador1> ;
        <tipo2> <identificador2> := <inicialización> ;
        ...
        <tipoN> <identificadorN> ;
    }
    
Uniones, `unown`, se representan de la misma manera:

    unown <identificador> {
        
        <tipo1> <identificador1> ;
    
        <tipo2> <identificador2> := <inicialización> ;
        ...
        <tipoN> <identificadorN> ;
    }

Para acceder a un atributo de un registro o unión, se utiliza el operador `.`.

    registro.campo
    

Ejemplo:

    registeer persona {   
        intmonchan cedula; 
        onix nombre;
        intmonchan edad;
    }

    voidporeon main () {
    
       registeer persona p;
       p.edad := 21;
       
    }
   
    
### Selector

    if <expresiónBooleana> {
        ...
    }

    if <expresiónBooleana> 
       <instrucción>;

    if <expresiónBooleana> {
        ...
    } else {
        ...
    }

    if <expresiónBooleana> {
        ...
    } elsif <expresiónBooleana2> {
        ...
    }

    if <expresiónBooleana> {
        ...
    } elsif <expresiónBooleana2> {
        ...
    } else {
        ...
    }

### Iteraciones



    for <identificador> from <expresión> to <expresión> {
         ...
    }

    for <identificador> from <expresión> to <expresión> by <expresión> {
         ...
    }

    while <expresiónBooleana> {
         ...
    }

### Entrada/Salida

Las palabras reservadas para entreda y salida son `read`, `print` y `println`.

    intmonchan num;
    print ("Ingrese su numero favorito: ");
    read(num);
    ...
    
### Precedencia de Operadores

De mayor a menor precedencia.

             Operador | Descripción
             -------- | -----------
    !    - unario     | Negación booleana y menos unario
    ^                 | Potenciación
    *    /    %       | Multiplicación, división y módulo
    +    -            | Suma y resta
    <    <=   >=    > | Relacionales
    =    !=           | Igualdad y desigualdad
    &&                | Operador lógico y
   &#124;&#124;       | Operador lógico o

### Asignación

    :=

### Declaración e Inicialización de Variables

Pasado por Valor

    <tipo> <identificador> ;
    <tipo> <identificador> := <valor> ;
    <tipo> <identificador1> , <identificador2> ;
    <tipo> <identificador1> , <identificador2> := <valor1> , <valor2> ;


Pasado por Referencia

    <tipo> var <identificador> ;
    <tipo> <identificador, var <identificador> ;

### Etiquetas

Se representan de la siguiente manera:

    tag: <identificador> ;


* BOOM - break
* BOOM etiqueta - break 
* continue etiqueta
* continue

### Switch

Los rangos son disjuntos y valor default es opcional. Deben haber al menos
dos case en el switch.

    switch <expresión> {
        case <rango1> -> { ... }
        case <rango2> -> { ... }
        ...
        default       -> { ... }
    }

### Conversiones Explícitas

* intToFloatzel
* floatToIntmonchan
* charToIntmonchan
* intToCharizard